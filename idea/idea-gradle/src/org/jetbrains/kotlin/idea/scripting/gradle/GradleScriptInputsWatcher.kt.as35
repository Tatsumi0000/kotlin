/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.idea.scripting.gradle

import com.intellij.openapi.components.*
import com.intellij.openapi.externalSystem.service.project.autoimport.ConfigurationFileCrcFactory
import com.intellij.openapi.project.Project
import com.intellij.openapi.util.io.FileUtil
import com.intellij.openapi.vfs.VfsUtil
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.util.PathUtil
import org.jetbrains.annotations.TestOnly
import org.jetbrains.plugins.gradle.settings.GradleLocalSettings
import java.nio.file.Paths

@State(
    name = "KotlinGradleScriptsModificationInfo",
    storages = [Storage(StoragePathMacros.CACHE_FILE)]
)
class GradleScriptInputsWatcher(val project: Project) : PersistentStateComponent<GradleScriptInputsWatcher.MyStorage> {
    companion object {
        fun getInstance(project: Project): GradleScriptInputsWatcher {
            return ServiceManager.getService(project, GradleScriptInputsWatcher::class.java)
        }
    }

    private var storage = MyStorage()

    init {
        initStorage(project)
    }

    private fun initStorage(project: Project) {
        val localSettings = GradleLocalSettings.getInstance(project)
        localSettings.externalConfigModificationStamps.forEach { (path, stamp) ->
            val file = VfsUtil.findFile(Paths.get(path), true)
            if (file != null && !file.isDirectory) {
                val calculateCrc = ConfigurationFileCrcFactory(project, file).create()
                if (calculateCrc != stamp) {
                    storage.fileChanged(getNormalizedPath(file), file.timeStamp)
                }
            }
        }
    }

    fun lastModifiedFileTimeStamp(file: VirtualFile): Long = storage.lastModifiedTimeStampExcept(getNormalizedPath(file))

    fun areRelatedFilesUpToDate(file: VirtualFile, timeStamp: Long): Boolean {
        return lastModifiedFileTimeStamp(file) < timeStamp
    }

    fun getNormalizedPath(file: VirtualFile): String {
        val canonized = PathUtil.getCanonicalPath(file.path) ?: file.path
        return FileUtil.toSystemIndependentName(canonized)
    }

    class MyStorage(
        private var lastModifiedTS: Long = Long.MIN_VALUE,
        private val lastModifiedFiles: MutableList<String> = arrayListOf(),
        private var previousModifiedTS: Long = Long.MIN_VALUE,
        private val previousModifiedFiles: MutableList<String> = arrayListOf()
    ) {
        fun lastModifiedTimeStampExcept(file: String): Long {
            if (lastModifiedFiles.contains(file) && lastModifiedFiles.size == 1) {
                return previousModifiedTS
            }

            return lastModifiedTS
        }

        fun fileChanged(file: String, ts: Long) {
            when {
                ts > lastModifiedTS -> {
                    previousModifiedFiles.clear()
                    previousModifiedFiles.addAll(lastModifiedFiles)
                    previousModifiedTS = lastModifiedTS

                    lastModifiedTS = ts
                    lastModifiedFiles.clear()
                    lastModifiedFiles.add(file)
                }
                ts == lastModifiedTS -> {
                    lastModifiedFiles.add(file)
                }
                ts == previousModifiedTS -> {
                    previousModifiedFiles.add(file)
                }
            }
        }
    }

    override fun getState(): MyStorage {
        return storage
    }

    override fun loadState(state: MyStorage) {
        this.storage = state
    }
}